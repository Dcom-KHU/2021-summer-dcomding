# 2주차 문제1 - 해밍코드

|구분|값|
|---|---|
|난이도|1|
|점수|1|
|출처|자작|

## 문제 설명
컴퓨터 통신에는 노이즈, 물리적 결함 등으로 데이터가 훼손될 가능성이 있습니다. 그래서 컴퓨터 통신에서 데이터 훼손되었는지 여부를 확인하는 것은 매우 중요합니다.

`해밍코드`는 1비트의 데이터의 훼손 여부를 확인할 수 있는 방법입니다. 해밍코드가 동작하는 방법은 아래와 같습니다.

> 2<sup>n</sup>비트 자리마다 체크 비트를 두고, 각각 패리티 비트를 저장한다.

본 문제에서는 체크 비트를 포함한 `총 비트가 최대 15비트`인 `짝수 패리티 비트`를 사용하는 해밍코드만을 사용하겠습니다.<br>
15비트에 대해 비트 위치에 따른 데이터는 아래와 같습니다. (`P`:체크 비트, `D`:데이터 비트)

|비트위치|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|값|D11|D10|D9|D8|D7|D6|D5|`P4`|D4|D3|D2|`P3`|D1|`P2`|`P1`|

이때, 각각의 체크 비트들은 아래와 같이 구성됩니다.
- P1 : XOR(D1, D2, D4, D5, D7, D9, D11)
- P2 : XOR(D1, D3, D4, D6, D7, D10, D11)
- P3 : XOR(D2, D3, D4, D8, D9, D10, D11)
- P4 : XOR(D5, D6, D7, D8, D9, D10, D11)

예를 들어, 숫자 23이 주어졌을 때, 아래와 같이 작성될 수 있습니다.<br>
23을 11비트 2진수로 나타내면 00000010111입니다.

|비트위치|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|값|0|0|0|0|0|0|1|`P4`|0|1|1|`P3`|1|`P2`|`P1`|

각각의 체크 비트를 계산하면
- P1 : XOR(1, 1, 0, 1, 0, 0, 0) = 1
- P2 : XOR(1, 1, 0, 0, 0, 0, 0) = 0
- P3 : XOR(1, 1, 0, 0, 0, 0, 0) = 0
- P4 : XOR(1, 0, 0, 0, 0, 0, 0) = 1

따라서 완성된 비트는 아래와 같습니다.
|비트위치|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|값|0|0|0|0|0|0|1|1|0|1|1|0|1|0|1|

해밍 코드를 이용해 오류를 확인하는 방법은 간단합니다.<br>
앞서 체크 비트들을 구했던 방법들과 그 체크비트를 XOR을 통해 계산한 결과를 이용해 오류를 확인할 수 있습니다. (`C` : 검증 비트)

- C1 : XOR(D1, D2, D4, D5, D7, D9, D11, `P1`)
- C2 : XOR(D1, D3, D4, D6, D7, D10, D11, `P2`)
- C3 : XOR(D2, D3, D4, D8, D9, D10, D11, `P3`)
- C4 : XOR(D5, D6, D7, D8, D9, D10, D11, `P4`)

이렇게 계산을 마친 검증 비트들을 C4 C3 C2 C1 순으로 두고, 이를 10진수로 바꾸면 몇 번째 비트에 오류가 있는지를 나타냅니다. 0이라면 오류가 없다는 것을 의미합니다.

위의 예시로 23을 000000110110101 이라는 해밍 코드로 나타냈습니다. 만약 5번째 비트에 오류가 생겨 0으로 변경되었다고 가정해봅시다.

|비트위치|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|값|0|0|0|0|0|0|1|1|0|1|0|0|1|0|1|

이 경우 검증 비트들은 아래와 같이 계산될 수 있습니다.

- C1 : XOR(1, 0, 0, 1, 0, 0, 0, 1) = 1
- C2 : XOR(1, 1, 0, 0, 0, 0, 0, 0) = 0
- C3 : XOR(0, 1, 0, 0, 0, 0, 0, 0) = 1
- C4 : XOR(1, 0, 0, 0, 0, 0, 0, 1) = 0

이 검증 비트들을 순서대로 나타내면 0101 = 5이므로 5번째 비트가 이상이 생겼음을 쉽게 확인할 수 있습니다.

위와 같이 해밍코드 비트 B<sub>1</sub>~B<sub>15</sub>들이 주어졌을 때, 주어진 해밍코드에 오류가 있을 경우 이 오류를 고친 원래의 10진수 값을 출력하는 프로그램을 작성해주세요.

## 제한 사항
- B의 크기는 항상 15
- B<sub>i</sub> = 0 or 1
- 두 비트 이상 오류가 나는 경우는 주어지지 않습니다.

## 입력
첫째 줄에 B<sub>1</sub>부터 B<sub>15</sub> 순으로 주어집니다.

## 출력
첫째 줄에 오류가 고쳐진 10진수 값을 출력합니다.

## 예시
### 예시1
**입력**

```
1 0 1 0 1 1 0 1 1 0 0 0 0 0 0
```

**출력**
```
23
```

**설명**

문제의 예시와 같습니다.

### 예시2
**입력**

```
1 0 1 0 0 1 0 1 1 0 0 0 0 0 0
```

**출력**
```
23
```

**설명**

문제의 예시와 같습니다.

### 예시3
**입력**

```
1 1 0 1 1 0 0 1 0 0 1 1 1 1 0
```

**출력**
```
450
```

**설명**

- C1 : XOR(0, 1, 0, 0, 1, 1, 0, 1) = 0
- C2 : XOR(0, 0, 0, 0, 1, 1, 0, 1) = 1
- C3 : XOR(1, 0, 0, 1, 1, 1, 0, 1) = 1
- C4 : XOR(0, 0, 1, 1, 1, 1, 0, 1) = 1

검증 비트들의 값이 1110이므로 14번째 비트에 오류가 발생했습니다. 따라서 14번째 비트(D10)를 1에서 0으로 바꿔준 후 값을 계산합니다.

D1 ~ D11은 각각 0 1 0 0 0 0 1 1 1 `0` 0 이므로 00111000010을 10진수로 변경하면 450이 정답입니다.

### 예시4
**입력**

```
1 1 1 1 1 0 1 1 0 1 1 1 1 1 0
```

**출력**
```
1003
```

**설명**

- C1 : XOR(1, 1, 1, 0, 1, 1, 0, 1) = 0
- C2 : XOR(1, 0, 1, 1, 1, 1, 0, 1) = 0
- C3 : XOR(1, 0, 1, 1, 1, 1, 0, 1) = 0
- C4 : XOR(0, 1, 1, 1, 1, 1, 0, 1) = 0

검증 비트들의 값이 0000이므로 오류가 발생하지 않았습니다.

D1 ~ D11은 각각 1 1 0 1 0 1 1 1 1 1 0이므로 01111101011을 10진수로 변경하면 1003이 정답입니다.
